{"title":"委托在重构中的运用","slug":"Delegate_in_Refactoring","date":"2019-03-09T10:49:35.000Z","updated":"2023-09-08T06:12:36.540Z","comments":true,"path":"api/articles/Delegate_in_Refactoring.json","excerpt":null,"covers":null,"content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>最近在工作中的一次重构过程中运用到了委托，记录一下。</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>有一段示例代码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProjectAClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">CallMethod</span><span class=\"params\">(<span class=\"type\">bool</span> isTrue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ProjectB_StaticClass.<span class=\"built_in\">DoSomething</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>后来因为业务的不断发展，需要把ProjectB从整个解决方案中移除掉。<br>ProjectB_StaticClassB.DoSomething();需要替换成 ProjectC_StaticClassC.DoSomething();<br>但是项目ProjectC需要引用ProjectA，故不能直接进行引用，否则会造成项目之间的循环依赖。  </p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>ProjectAClass添加一个委托事件,CallMethod函数添加一个<strong>Dosometing dosometing</strong>的参数。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectAClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Dosometing</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CallMethod</span>(<span class=\"params\"><span class=\"built_in\">bool</span> isTrue, Dosometing dosometing</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dosometing?.Invoke();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>具体的调用代码处就变成了</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProjectAClass.CallMethod(<span class=\"literal\">true</span>,<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;ProjectC_StaticClassC.DoSomething();&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>若ProjectAClass.CallMethod方法多地方出现，然而没有办法一下修改到位。可以通过参数默认值的方式来实现修改。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CallMethod</span>(<span class=\"params\"><span class=\"built_in\">bool</span> isTrue, Dosometing dosometing=<span class=\"literal\">null</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dosometing == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ProjectB_StaticClass.DoSomething();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dosometing.Invoke(); <span class=\"comment\">// or dosometing()</span></span><br><span class=\"line\">        &#125;         </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法可以避免原来的调用方法进行大面积的修改。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>重构之后的代码ProjectAClass只需要判断条件是否满足，满足则dosometing，而不需要知道dosometing这个委托方法中具体细节。</p>\n","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>最近在工作中的一次重构过程中运用到了委托，记录一下。</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>有一段示例代码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProjectAClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">CallMethod</span><span class=\"params\">(<span class=\"type\">bool</span> isTrue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ProjectB_StaticClass.<span class=\"built_in\">DoSomething</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>后来因为业务的不断发展，需要把ProjectB从整个解决方案中移除掉。<br>ProjectB_StaticClassB.DoSomething();需要替换成 ProjectC_StaticClassC.DoSomething();<br>但是项目ProjectC需要引用ProjectA，故不能直接进行引用，否则会造成项目之间的循环依赖。  </p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>ProjectAClass添加一个委托事件,CallMethod函数添加一个<strong>Dosometing dosometing</strong>的参数。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ProjectAClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">Dosometing</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CallMethod</span>(<span class=\"params\"><span class=\"built_in\">bool</span> isTrue, Dosometing dosometing</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dosometing?.Invoke();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>具体的调用代码处就变成了</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProjectAClass.CallMethod(<span class=\"literal\">true</span>,<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;ProjectC_StaticClassC.DoSomething();&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>若ProjectAClass.CallMethod方法多地方出现，然而没有办法一下修改到位。可以通过参数默认值的方式来实现修改。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">CallMethod</span>(<span class=\"params\"><span class=\"built_in\">bool</span> isTrue, Dosometing dosometing=<span class=\"literal\">null</span></span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTrue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dosometing == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ProjectB_StaticClass.DoSomething();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            dosometing.Invoke(); <span class=\"comment\">// or dosometing()</span></span><br><span class=\"line\">        &#125;         </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法可以避免原来的调用方法进行大面积的修改。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>重构之后的代码ProjectAClass只需要判断条件是否满足，满足则dosometing，而不需要知道dosometing这个委托方法中具体细节。</p>\n","categories":[{"name":"代码世界","path":"api/categories/代码世界.json"},{"name":"重构","path":"api/categories/重构.json"}],"tags":[{"name":"重构","path":"api/tags/重构.json"}]}